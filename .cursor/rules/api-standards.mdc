---
alwaysApply: true
---

# API Standards

## üèó API Architecture

### **Next.js API Routes Structure**

```typescript
// ‚úÖ Good: Proper API route structure
// apps/web/app/api/campaigns/route.ts
import { NextRequest, NextResponse } from 'next/server';

import { createCampaign, getCampaigns } from '~/lib/api/campaigns';

export async function GET(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url);
    const page = parseInt(searchParams.get('page') || '1');
    const limit = parseInt(searchParams.get('limit') || '10');

    const campaigns = await getCampaigns({ page, limit });

    return NextResponse.json({
      success: true,
      data: campaigns,
      pagination: {
        page,
        limit,
        total: campaigns.length,
      },
    });
  } catch (error) {
    console.error('GET /api/campaigns error:', error);
    return NextResponse.json(
      {
        success: false,
        error: 'Failed to fetch campaigns',
      },
      { status: 500 },
    );
  }
}

export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const campaign = await createCampaign(body);

    return NextResponse.json(
      {
        success: true,
        data: campaign,
      },
      { status: 201 },
    );
  } catch (error) {
    console.error('POST /api/campaigns error:', error);
    return NextResponse.json(
      {
        success: false,
        error: 'Failed to create campaign',
      },
      { status: 400 },
    );
  }
}
```

### **Dynamic API Routes**

```typescript
// ‚úÖ Good: Dynamic route with proper typing
// apps/web/app/api/campaigns/[id]/route.ts
interface CampaignRouteParams {
  params: Promise<{ id: string }>;
}

export async function GET(
  request: NextRequest,
  { params }: CampaignRouteParams,
) {
  try {
    const { id } = await params;
    const campaign = await getCampaignById(id);

    if (!campaign) {
      return NextResponse.json(
        { success: false, error: 'Campaign not found' },
        { status: 404 },
      );
    }

    return NextResponse.json({
      success: true,
      data: campaign,
    });
  } catch (error) {
    console.error(`GET /api/campaigns/${id} error:`, error);
    return NextResponse.json(
      { success: false, error: 'Failed to fetch campaign' },
      { status: 500 },
    );
  }
}

export async function PUT(
  request: NextRequest,
  { params }: CampaignRouteParams,
) {
  try {
    const { id } = await params;
    const body = await request.json();

    const updatedCampaign = await updateCampaign(id, body);

    return NextResponse.json({
      success: true,
      data: updatedCampaign,
    });
  } catch (error) {
    console.error(`PUT /api/campaigns/${id} error:`, error);
    return NextResponse.json(
      { success: false, error: 'Failed to update campaign' },
      { status: 400 },
    );
  }
}

export async function DELETE(
  request: NextRequest,
  { params }: CampaignRouteParams,
) {
  try {
    const { id } = await params;
    await deleteCampaign(id);

    return NextResponse.json({
      success: true,
      message: 'Campaign deleted successfully',
    });
  } catch (error) {
    console.error(`DELETE /api/campaigns/${id} error:`, error);
    return NextResponse.json(
      { success: false, error: 'Failed to delete campaign' },
      { status: 500 },
    );
  }
}
```

## üîÑ API Response Patterns

### **Standard Response Format**

```typescript
// ‚úÖ Good: Consistent API response structure
interface ApiResponse<T> {
  success: boolean;
  data?: T;
  error?: string;
  message?: string;
  pagination?: {
    page: number;
    limit: number;
    total: number;
    totalPages: number;
  };
}

// ‚úÖ Good: Success response helper
function createSuccessResponse<T>(data: T, message?: string): ApiResponse<T> {
  return {
    success: true,
    data,
    message,
  };
}

// ‚úÖ Good: Error response helper
function createErrorResponse(
  error: string,
  statusCode: number = 400,
): Response {
  return NextResponse.json(
    {
      success: false,
      error,
    },
    { status: statusCode },
  );
}
```

### **Pagination Patterns**

```typescript
// ‚úÖ Good: Paginated response helper
interface PaginatedResponse<T> extends ApiResponse<T[]> {
  pagination: {
    page: number;
    limit: number;
    total: number;
    totalPages: number;
    hasNext: boolean;
    hasPrev: boolean;
  };
}

function createPaginatedResponse<T>(
  data: T[],
  page: number,
  limit: number,
  total: number,
): PaginatedResponse<T> {
  const totalPages = Math.ceil(total / limit);

  return {
    success: true,
    data,
    pagination: {
      page,
      limit,
      total,
      totalPages,
      hasNext: page < totalPages,
      hasPrev: page > 1,
    },
  };
}
```

## üîê Authentication & Authorization

### **API Route Protection**

```typescript
// ‚úÖ Good: Authentication middleware
import { cookies } from 'next/headers';

import { createServerClient } from '@supabase/ssr';

async function requireAuth(request: NextRequest) {
  const cookieStore = await cookies();

  const supabase = createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        getAll() {
          return cookieStore.getAll();
        },
        setAll(cookiesToSet) {
          try {
            cookiesToSet.forEach(({ name, value, options }) =>
              cookieStore.set(name, value, options),
            );
          } catch {
            // The `setAll` method was called from a Server Component.
            // This can be ignored if you have middleware refreshing
            // user sessions.
          }
        },
      },
    },
  );

  const {
    data: { user },
    error,
  } = await supabase.auth.getUser();

  if (error || !user) {
    throw new Error('Unauthorized');
  }

  return { user, supabase };
}

// ‚úÖ Good: Protected API route
export async function GET(request: NextRequest) {
  try {
    const { user, supabase } = await requireAuth(request);

    // Continue with authenticated request
    const campaigns = await getCampaignsForUser(user.id, supabase);

    return NextResponse.json(createSuccessResponse(campaigns));
  } catch (error) {
    if (error instanceof Error && error.message === 'Unauthorized') {
      return createErrorResponse('Unauthorized', 401);
    }

    console.error('GET /api/campaigns error:', error);
    return createErrorResponse('Internal server error', 500);
  }
}
```

### **Organization-based Authorization**

```typescript
// ‚úÖ Good: Organization-scoped API routes
async function requireOrganizationAccess(
  request: NextRequest,
  organizationId: string,
) {
  const { user, supabase } = await requireAuth(request);

  // Check if user has access to organization
  const { data: userOrg, error } = await supabase
    .from('user_organizations')
    .select('role')
    .eq('user_id', user.id)
    .eq('organization_id', organizationId)
    .single();

  if (error || !userOrg) {
    throw new Error('Access denied');
  }

  return { user, supabase, role: userOrg.role };
}

export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ organizationId: string }> },
) {
  try {
    const { organizationId } = await params;
    const { user, supabase, role } = await requireOrganizationAccess(
      request,
      organizationId,
    );

    const campaigns = await getCampaignsForOrganization(
      organizationId,
      supabase,
    );

    return NextResponse.json(createSuccessResponse(campaigns));
  } catch (error) {
    if (error instanceof Error && error.message === 'Access denied') {
      return createErrorResponse('Access denied', 403);
    }

    console.error('GET /api/organizations/[id]/campaigns error:', error);
    return createErrorResponse('Internal server error', 500);
  }
}
```

## üìä Data Validation

### **Request Validation**

```typescript
// ‚úÖ Good: Zod schema validation
import { z } from 'zod';

const createCampaignSchema = z.object({
  name: z.string().min(1, 'Name is required').max(255, 'Name too long'),
  description: z.string().optional(),
  startDate: z.string().datetime(),
  endDate: z.string().datetime().optional(),
  agentId: z.string().uuid(),
  callingHours: z.string(),
  maxAttempts: z.number().min(1).max(10),
  dailyCallCap: z.number().min(1).max(1000),
  script: z.string(),
  retryLogic: z.string(),
});

const updateCampaignSchema = createCampaignSchema.partial();

export async function POST(request: NextRequest) {
  try {
    const body = await request.json();

    // Validate request body
    const validatedData = createCampaignSchema.parse(body);

    const campaign = await createCampaign(validatedData);

    return NextResponse.json(createSuccessResponse(campaign), { status: 201 });
  } catch (error) {
    if (error instanceof z.ZodError) {
      return NextResponse.json(
        {
          success: false,
          error: 'Validation failed',
          details: error.errors,
        },
        { status: 400 },
      );
    }

    console.error('POST /api/campaigns error:', error);
    return createErrorResponse('Failed to create campaign', 500);
  }
}
```

### **Query Parameter Validation**

```typescript
// ‚úÖ Good: Query parameter validation
const querySchema = z.object({
  page: z.string().transform(Number).pipe(z.number().min(1)),
  limit: z.string().transform(Number).pipe(z.number().min(1).max(100)),
  status: z.enum(['draft', 'active', 'paused', 'completed']).optional(),
  search: z.string().optional(),
  sortBy: z.enum(['name', 'created_at', 'status']).optional(),
  sortOrder: z.enum(['asc', 'desc']).optional(),
});

export async function GET(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url);

    // Validate query parameters
    const query = querySchema.parse(Object.fromEntries(searchParams));

    const campaigns = await getCampaigns(query);

    return NextResponse.json(createSuccessResponse(campaigns));
  } catch (error) {
    if (error instanceof z.ZodError) {
      return NextResponse.json(
        {
          success: false,
          error: 'Invalid query parameters',
          details: error.errors,
        },
        { status: 400 },
      );
    }

    console.error('GET /api/campaigns error:', error);
    return createErrorResponse('Failed to fetch campaigns', 500);
  }
}
```

## üîÑ External API Integration

### **ElevenLabs API Integration**

```typescript
// ‚úÖ Good: External API client
class ElevenLabsAPI {
  private baseUrl: string;
  private apiKey: string;

  constructor() {
    this.baseUrl = 'https://api.elevenlabs.io/v1';
    this.apiKey = process.env.ELEVENLABS_API_KEY!;
  }

  async generateSpeech(text: string, voiceId: string): Promise<ArrayBuffer> {
    const response = await fetch(`${this.baseUrl}/text-to-speech/${voiceId}`, {
      method: 'POST',
      headers: {
        'xi-api-key': this.apiKey,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        text,
        model_id: 'eleven_multilingual_v2',
        voice_settings: {
          stability: 0.5,
          similarity_boost: 0.75,
        },
      }),
    });

    if (!response.ok) {
      const error = await response.json().catch(() => ({}));
      throw new Error(
        `ElevenLabs API error: ${error.detail || response.statusText}`,
      );
    }

    return response.arrayBuffer();
  }

  async getVoices(): Promise<Voice[]> {
    const response = await fetch(`${this.baseUrl}/voices`, {
      headers: {
        'xi-api-key': this.apiKey,
      },
    });

    if (!response.ok) {
      throw new Error(`Failed to fetch voices: ${response.statusText}`);
    }

    const data = await response.json();
    return data.voices;
  }
}

// ‚úÖ Good: API route for voice generation
export async function POST(request: NextRequest) {
  try {
    const { text, voiceId } = await request.json();

    if (!text || !voiceId) {
      return createErrorResponse('Text and voiceId are required', 400);
    }

    const elevenLabs = new ElevenLabsAPI();
    const audioBuffer = await elevenLabs.generateSpeech(text, voiceId);

    return new Response(audioBuffer, {
      headers: {
        'Content-Type': 'audio/mpeg',
        'Content-Length': audioBuffer.byteLength.toString(),
      },
    });
  } catch (error) {
    console.error('POST /api/voice/generate error:', error);
    return createErrorResponse('Failed to generate speech', 500);
  }
}
```

### **Twilio Webhook Integration**

```typescript
// ‚úÖ Good: Twilio webhook handler
import twilio from 'twilio';

const validateTwilioRequest = (request: NextRequest, body: string) => {
  const authToken = process.env.TWILIO_AUTH_TOKEN!;
  const url = request.url;
  const params = new URLSearchParams(body);

  const signature = request.headers.get('x-twilio-signature');
  if (!signature) {
    throw new Error('Missing Twilio signature');
  }

  const expectedSignature = twilio.validateRequest(
    authToken,
    signature,
    url,
    params,
  );

  if (!expectedSignature) {
    throw new Error('Invalid Twilio signature');
  }
};

export async function POST(request: NextRequest) {
  try {
    const body = await request.text();

    // Validate Twilio request
    validateTwilioRequest(request, body);

    const formData = new URLSearchParams(body);
    const callSid = formData.get('CallSid');
    const callStatus = formData.get('CallStatus');

    // Process webhook
    await processTwilioWebhook({
      callSid,
      callStatus,
      formData: Object.fromEntries(formData),
    });

    return new Response('OK', { status: 200 });
  } catch (error) {
    console.error('POST /api/twilio/webhook error:', error);
    return new Response('Error', { status: 400 });
  }
}
```

## üéØ Error Handling

### **Comprehensive Error Handling**

```typescript
// ‚úÖ Good: Error handling utilities
class ApiError extends Error {
  constructor(
    message: string,
    public statusCode: number = 500,
    public code?: string,
  ) {
    super(message);
    this.name = 'ApiError';
  }
}

function handleApiError(error: unknown): Response {
  if (error instanceof ApiError) {
    return NextResponse.json(
      {
        success: false,
        error: error.message,
        code: error.code,
      },
      { status: error.statusCode },
    );
  }

  if (error instanceof z.ZodError) {
    return NextResponse.json(
      {
        success: false,
        error: 'Validation failed',
        details: error.errors,
      },
      { status: 400 },
    );
  }

  console.error('API Error:', error);

  return NextResponse.json(
    {
      success: false,
      error: 'Internal server error',
    },
    { status: 500 },
  );
}

// ‚úÖ Good: Error handling wrapper
export async function GET(request: NextRequest) {
  try {
    // API logic here
    const campaigns = await getCampaigns();
    return NextResponse.json(createSuccessResponse(campaigns));
  } catch (error) {
    return handleApiError(error);
  }
}
```

## üìä Rate Limiting & Caching

### **Rate Limiting**

```typescript
// ‚úÖ Good: Rate limiting middleware
import { Ratelimit } from '@upstash/ratelimit';
import { Redis } from '@upstash/redis';

const redis = new Redis({
  url: process.env.UPSTASH_REDIS_REST_URL!,
  token: process.env.UPSTASH_REDIS_REST_TOKEN!,
});

const ratelimit = new Ratelimit({
  redis,
  limiter: Ratelimit.slidingWindow(10, '1 m'),
});

async function checkRateLimit(request: NextRequest) {
  const ip = request.ip ?? '127.0.0.1';
  const { success, limit, reset, remaining } = await ratelimit.limit(ip);

  if (!success) {
    throw new ApiError('Rate limit exceeded', 429);
  }

  return { limit, reset, remaining };
}

export async function POST(request: NextRequest) {
  try {
    await checkRateLimit(request);

    // Continue with API logic
    const body = await request.json();
    const campaign = await createCampaign(body);

    return NextResponse.json(createSuccessResponse(campaign), { status: 201 });
  } catch (error) {
    return handleApiError(error);
  }
}
```

### **Response Caching**

```typescript
// ‚úÖ Good: Cache headers for GET requests
export async function GET(request: NextRequest) {
  try {
    const campaigns = await getCampaigns();

    const response = NextResponse.json(createSuccessResponse(campaigns));

    // Add cache headers
    response.headers.set(
      'Cache-Control',
      'public, s-maxage=60, stale-while-revalidate=300',
    );

    return response;
  } catch (error) {
    return handleApiError(error);
  }
}
```

## üìã Best Practices Checklist

### **API Design**

- [ ] Use consistent response formats
- [ ] Implement proper error handling
- [ ] Add request validation with Zod
- [ ] Use appropriate HTTP status codes
- [ ] Implement pagination for list endpoints

### **Security**

- [ ] Validate all input data
- [ ] Implement proper authentication
- [ ] Use HTTPS for all requests
- [ ] Add rate limiting
- [ ] Validate external webhooks

### **Performance**

- [ ] Add appropriate cache headers
- [ ] Implement response compression
- [ ] Use database indexes
- [ ] Monitor API response times
- [ ] Implement proper logging

### **Documentation**

- [ ] Document all API endpoints
- [ ] Include request/response examples
- [ ] Document error codes
- [ ] Keep API documentation updated
- [ ] Use OpenAPI/Swagger when possible

### **Testing**

- [ ] Write unit tests for API routes
- [ ] Test error scenarios
- [ ] Validate response formats
- [ ] Test authentication flows
- [ ] Monitor API usage in production
      alwaysApply: false

---
