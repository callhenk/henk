# Supabase Database Standards

## üèó Database Architecture

### **Supabase Setup**

```typescript
// ‚úÖ Good: Proper Supabase client configuration
import { createClient } from '@supabase/supabase-js';

const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL!;
const supabaseAnonKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!;

export const supabase = createClient(supabaseUrl, supabaseAnonKey, {
  auth: {
    autoRefreshToken: true,
    persistSession: true,
    detectSessionInUrl: true,
  },
});
```

### **Database Schema Patterns**

```sql
-- ‚úÖ Good: Campaigns table with proper constraints
CREATE TABLE campaigns (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  name VARCHAR(255) NOT NULL,
  description TEXT,
  status VARCHAR(20) NOT NULL DEFAULT 'draft' CHECK (status IN ('draft', 'active', 'paused', 'completed')),
  agent_id UUID REFERENCES agents(id),
  leads_count INTEGER DEFAULT 0,
  contacted_count INTEGER DEFAULT 0,
  conversions_count INTEGER DEFAULT 0,
  revenue DECIMAL(10,2) DEFAULT 0,
  start_date DATE NOT NULL,
  end_date DATE,
  calling_hours VARCHAR(100),
  max_attempts INTEGER DEFAULT 3,
  daily_call_cap INTEGER DEFAULT 50,
  script TEXT,
  retry_logic TEXT,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  created_by UUID REFERENCES auth.users(id),
  organization_id UUID REFERENCES organizations(id)
);

-- ‚úÖ Good: Row Level Security (RLS) policies
ALTER TABLE campaigns ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view campaigns in their organization" ON campaigns
  FOR SELECT USING (
    organization_id IN (
      SELECT organization_id FROM user_organizations
      WHERE user_id = auth.uid()
    )
  );

CREATE POLICY "Users can insert campaigns in their organization" ON campaigns
  FOR INSERT WITH CHECK (
    organization_id IN (
      SELECT organization_id FROM user_organizations
      WHERE user_id = auth.uid()
    )
  );
```

## üîÑ Data Access Patterns

### **Supabase Hooks Usage**

```typescript
// ‚úÖ Good: Proper Supabase hooks from packages/supabase
import { useSupabase } from '@kit/supabase/hooks/use-supabase';
import { useUser } from '@kit/supabase/hooks/use-user';

export function useCampaigns() {
  const { supabase } = useSupabase();
  const { user } = useUser();

  const [campaigns, setCampaigns] = useState<Campaign[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  const fetchCampaigns = useCallback(async () => {
    try {
      setLoading(true);
      setError(null);

      const { data, error: fetchError } = await supabase
        .from('campaigns')
        .select(
          `
          *,
          agents:agent_id(name, voice_id),
          organizations:organization_id(name)
        `,
        )
        .order('created_at', { ascending: false });

      if (fetchError) throw fetchError;
      setCampaigns(data || []);
    } catch (err) {
      setError(
        err instanceof Error ? err.message : 'Failed to fetch campaigns',
      );
    } finally {
      setLoading(false);
    }
  }, [supabase]);

  useEffect(() => {
    if (user) {
      fetchCampaigns();
    }
  }, [user, fetchCampaigns]);

  return { campaigns, loading, error, refetch: fetchCampaigns };
}
```

### **CRUD Operations**

```typescript
// ‚úÖ Good: Create campaign with proper typing
export async function createCampaign(
  campaignData: CreateCampaignData,
): Promise<Campaign> {
  const { data, error } = await supabase
    .from('campaigns')
    .insert({
      ...campaignData,
      created_by: (await supabase.auth.getUser()).data.user?.id,
    })
    .select()
    .single();

  if (error) throw new Error(`Failed to create campaign: ${error.message}`);
  return data;
}

// ‚úÖ Good: Update campaign with optimistic updates
export async function updateCampaign(
  id: string,
  updates: Partial<Campaign>,
): Promise<Campaign> {
  const { data, error } = await supabase
    .from('campaigns')
    .update({
      ...updates,
      updated_at: new Date().toISOString(),
    })
    .eq('id', id)
    .select()
    .single();

  if (error) throw new Error(`Failed to update campaign: ${error.message}`);
  return data;
}

// ‚úÖ Good: Delete campaign with proper error handling
export async function deleteCampaign(id: string): Promise<void> {
  const { error } = await supabase.from('campaigns').delete().eq('id', id);

  if (error) throw new Error(`Failed to delete campaign: ${error.message}`);
}
```

## üéØ Real-time Subscriptions

### **Real-time Data Patterns**

```typescript
// ‚úÖ Good: Real-time campaign updates
export function useCampaignRealtime(campaignId: string) {
  const { supabase } = useSupabase();
  const [campaign, setCampaign] = useState<Campaign | null>(null);

  useEffect(() => {
    // Initial fetch
    const fetchCampaign = async () => {
      const { data, error } = await supabase
        .from('campaigns')
        .select('*')
        .eq('id', campaignId)
        .single();

      if (!error && data) {
        setCampaign(data);
      }
    };

    fetchCampaign();

    // Real-time subscription
    const subscription = supabase
      .channel(`campaign:${campaignId}`)
      .on(
        'postgres_changes',
        {
          event: 'UPDATE',
          schema: 'public',
          table: 'campaigns',
          filter: `id=eq.${campaignId}`,
        },
        (payload) => {
          setCampaign(payload.new as Campaign);
        },
      )
      .subscribe();

    return () => {
      subscription.unsubscribe();
    };
  }, [campaignId, supabase]);

  return campaign;
}
```

## üîê Authentication & Authorization

### **User Authentication**

```typescript
// ‚úÖ Good: Proper authentication handling
import { useAuth } from '@kit/supabase/hooks/use-auth';

export function useRequireAuth() {
  const { user, loading } = useAuth();
  const router = useRouter();

  useEffect(() => {
    if (!loading && !user) {
      router.push('/auth/sign-in');
    }
  }, [user, loading, router]);

  return { user, loading };
}

// ‚úÖ Good: Protected component wrapper
export function ProtectedComponent({ children }: { children: React.ReactNode }) {
  const { user, loading } = useRequireAuth();

  if (loading) {
    return <LoadingOverlay />;
  }

  if (!user) {
    return null; // Will redirect to sign-in
  }

  return <>{children}</>;
}
```

### **Organization-based Access**

```typescript
// ‚úÖ Good: Organization-scoped data access
export function useOrganizationCampaigns(organizationId: string) {
  const { supabase } = useSupabase();
  const [campaigns, setCampaigns] = useState<Campaign[]>([]);

  const fetchCampaigns = useCallback(async () => {
    const { data, error } = await supabase
      .from('campaigns')
      .select('*')
      .eq('organization_id', organizationId)
      .order('created_at', { ascending: false });

    if (error) throw error;
    setCampaigns(data || []);
  }, [supabase, organizationId]);

  useEffect(() => {
    fetchCampaigns();
  }, [fetchCampaigns]);

  return { campaigns, refetch: fetchCampaigns };
}
```

## üìä Data Relationships

### **Joins and Relationships**

```typescript
// ‚úÖ Good: Complex queries with joins
export async function getCampaignWithDetails(campaignId: string) {
  const { data, error } = await supabase
    .from('campaigns')
    .select(
      `
      *,
      agent:agents(
        id,
        name,
        voice_id,
        language,
        tone
      ),
      leads:campaign_leads(
        id,
        name,
        email,
        phone,
        status,
        last_contact_date
      ),
      conversations:campaign_conversations(
        id,
        duration,
        outcome,
        sentiment,
        created_at
      )
    `,
    )
    .eq('id', campaignId)
    .single();

  if (error) throw error;
  return data;
}
```

### **Pagination Patterns**

```typescript
// ‚úÖ Good: Paginated data fetching
export function usePaginatedCampaigns(page: number = 1, limit: number = 10) {
  const { supabase } = useSupabase();
  const [campaigns, setCampaigns] = useState<Campaign[]>([]);
  const [hasMore, setHasMore] = useState(true);
  const [loading, setLoading] = useState(false);

  const fetchCampaigns = useCallback(async () => {
    setLoading(true);

    const from = (page - 1) * limit;
    const to = from + limit - 1;

    const { data, error, count } = await supabase
      .from('campaigns')
      .select('*', { count: 'exact' })
      .range(from, to)
      .order('created_at', { ascending: false });

    if (error) throw error;

    setCampaigns(data || []);
    setHasMore((count || 0) > to + 1);
    setLoading(false);
  }, [supabase, page, limit]);

  useEffect(() => {
    fetchCampaigns();
  }, [fetchCampaigns]);

  return { campaigns, loading, hasMore, refetch: fetchCampaigns };
}
```

## üîç Query Optimization

### **Indexing Strategy**

```sql
-- ‚úÖ Good: Proper indexing for performance
CREATE INDEX idx_campaigns_organization_id ON campaigns(organization_id);
CREATE INDEX idx_campaigns_status ON campaigns(status);
CREATE INDEX idx_campaigns_created_at ON campaigns(created_at DESC);
CREATE INDEX idx_campaigns_agent_id ON campaigns(agent_id);

-- ‚úÖ Good: Composite indexes for common queries
CREATE INDEX idx_campaigns_org_status ON campaigns(organization_id, status);
CREATE INDEX idx_campaigns_org_date ON campaigns(organization_id, created_at DESC);
```

### **Query Optimization**

```typescript
// ‚úÖ Good: Optimized queries with proper selects
export async function getCampaignStats(organizationId: string) {
  const { data, error } = await supabase
    .from('campaigns')
    .select(
      `
      status,
      leads_count,
      contacted_count,
      conversions_count,
      revenue
    `,
    )
    .eq('organization_id', organizationId);

  if (error) throw error;

  // Calculate totals
  return data.reduce(
    (stats, campaign) => ({
      totalCampaigns: stats.totalCampaigns + 1,
      totalLeads: stats.totalLeads + campaign.leads_count,
      totalContacted: stats.totalContacted + campaign.contacted_count,
      totalConversions: stats.totalConversions + campaign.conversions_count,
      totalRevenue: stats.totalRevenue + parseFloat(campaign.revenue || '0'),
    }),
    {
      totalCampaigns: 0,
      totalLeads: 0,
      totalContacted: 0,
      totalConversions: 0,
      totalRevenue: 0,
    },
  );
}
```

## üõ°Ô∏è Security Patterns

### **Row Level Security (RLS)**

```sql
-- ‚úÖ Good: Comprehensive RLS policies
-- Campaigns table policies
CREATE POLICY "Users can view campaigns in their organization" ON campaigns
  FOR SELECT USING (
    organization_id IN (
      SELECT organization_id FROM user_organizations
      WHERE user_id = auth.uid() AND role IN ('admin', 'member')
    )
  );

CREATE POLICY "Users can create campaigns in their organization" ON campaigns
  FOR INSERT WITH CHECK (
    organization_id IN (
      SELECT organization_id FROM user_organizations
      WHERE user_id = auth.uid() AND role IN ('admin', 'member')
    )
  );

CREATE POLICY "Users can update campaigns in their organization" ON campaigns
  FOR UPDATE USING (
    organization_id IN (
      SELECT organization_id FROM user_organizations
      WHERE user_id = auth.uid() AND role IN ('admin', 'member')
    )
  );

CREATE POLICY "Admins can delete campaigns in their organization" ON campaigns
  FOR DELETE USING (
    organization_id IN (
      SELECT organization_id FROM user_organizations
      WHERE user_id = auth.uid() AND role = 'admin'
    )
  );
```

### **Data Validation**

```typescript
// ‚úÖ Good: Server-side validation with Supabase functions
export async function validateCampaignData(
  data: CreateCampaignData,
): Promise<boolean> {
  // Check if campaign name is unique within organization
  const { data: existing, error } = await supabase
    .from('campaigns')
    .select('id')
    .eq('organization_id', data.organization_id)
    .eq('name', data.name)
    .single();

  if (existing) {
    throw new Error('Campaign name already exists in this organization');
  }

  // Validate date ranges
  if (data.end_date && new Date(data.end_date) <= new Date(data.start_date)) {
    throw new Error('End date must be after start date');
  }

  return true;
}
```

## üìä Migration Patterns

### **Database Migrations**

```sql
-- ‚úÖ Good: Proper migration structure
-- 20241219010757_add_campaigns_table.sql

-- Create campaigns table
CREATE TABLE campaigns (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  name VARCHAR(255) NOT NULL,
  description TEXT,
  status VARCHAR(20) NOT NULL DEFAULT 'draft',
  -- ... other columns
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Add indexes
CREATE INDEX idx_campaigns_organization_id ON campaigns(organization_id);
CREATE INDEX idx_campaigns_status ON campaigns(status);

-- Enable RLS
ALTER TABLE campaigns ENABLE ROW LEVEL SECURITY;

-- Add policies
CREATE POLICY "Users can view campaigns in their organization" ON campaigns
  FOR SELECT USING (
    organization_id IN (
      SELECT organization_id FROM user_organizations
      WHERE user_id = auth.uid()
    )
  );

-- Add triggers for updated_at
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ language 'plpgsql';

CREATE TRIGGER update_campaigns_updated_at
  BEFORE UPDATE ON campaigns
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column();
```

## üéØ Best Practices Checklist

### **Database Design**

- [ ] Use UUIDs for primary keys
- [ ] Implement proper foreign key relationships
- [ ] Add appropriate indexes for performance
- [ ] Use CHECK constraints for data validation
- [ ] Implement RLS policies for security

### **Data Access**

- [ ] Use proper TypeScript interfaces for database types
- [ ] Implement error handling for all database operations
- [ ] Use optimistic updates for better UX
- [ ] Implement proper loading states
- [ ] Use real-time subscriptions where appropriate

### **Security**

- [ ] Enable RLS on all tables
- [ ] Implement organization-based access control
- [ ] Validate data on both client and server
- [ ] Use proper authentication checks
- [ ] Implement proper error messages

### **Performance**

- [ ] Use appropriate indexes
- [ ] Limit query results with pagination
- [ ] Use specific column selects instead of \*
- [ ] Implement proper caching strategies
- [ ] Monitor query performance

### **Code Organization**

- [ ] Use Supabase hooks from packages/supabase
- [ ] Implement proper error boundaries
- [ ] Use TypeScript for type safety
- [ ] Document complex queries
- [ ] Follow established patterns for CRUD operations
      alwaysApply: false

---
